"use strict";
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadStream = void 0;
const gax = require("google-gax");
const logger_1 = require("../util/logger");
const stream_1 = require("stream");
/**
 * ReadStream is responsible for reading data from a GRPC read stream
 * connection against the Storage Read API readRows method.
 *
 * @class
 * @extends EventEmitter
 * @memberof reader
 */
class ReadStream {
    constructor(streamName, session, readClient, options) {
        this.handleError = (err) => {
            var _a;
            this.trace('on error', err, JSON.stringify(err));
            if (this.isRetryableError(err)) {
                this.reconnect();
                return;
            }
            (_a = this._readStream) === null || _a === void 0 ? void 0 : _a.destroy(err);
            this._readStream = null;
        };
        /**
         * Get the name of the read stream associated with this connection.
         */
        this.getStreamName = () => {
            return this._streamName;
        };
        this._streamName = streamName;
        this._session = session;
        this._offset = 0;
        this._readClient = readClient;
        this._connection = null;
        this._readStream = null;
        this._callOptions = options;
        this.open();
    }
    open() {
        if (this.isOpen()) {
            this.close();
        }
        const client = this._readClient.getClient();
        const connection = client.readRows({
            readStream: this._streamName,
            offset: this._offset,
        }, this._callOptions);
        this._connection = connection;
        const passthrough = new stream_1.Transform({
            objectMode: true,
            transform: (response, _, callback) => {
                this.processReadRowsResponse(response);
                callback(null, response);
            },
        });
        this._readStream = this._connection.pipe(passthrough);
        this._connection.on('error', this.handleError);
        this._connection.on('close', () => {
            this.trace('connection closed');
        });
        this._connection.on('pause', () => {
            this.trace('connection paused');
        });
        this._connection.on('resume', async () => {
            this.trace('connection resumed');
        });
        this._connection.on('end', () => {
            this.trace('connection ended');
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    trace(msg, ...otherArgs) {
        (0, logger_1.logger)('read_stream', `[streamName: ${this._streamName}]`, msg, ...otherArgs);
    }
    isRetryableError(err) {
        if (!err) {
            return false;
        }
        const reconnectionErrorCodes = [
            gax.Status.ABORTED,
            gax.Status.CANCELLED,
            gax.Status.DEADLINE_EXCEEDED,
            gax.Status.INTERNAL,
            gax.Status.UNAVAILABLE,
        ];
        return !!err.code && reconnectionErrorCodes.includes(err.code);
    }
    processReadRowsResponse(response) {
        if (!response.rowCount) {
            return;
        }
        const rowCount = parseInt(response.rowCount, 10);
        this._offset += rowCount;
    }
    getReadSession() {
        return this._session;
    }
    getRowsStream() {
        return this._readStream;
    }
    /**
     * Check if connection is open and ready to read data.
     */
    isOpen() {
        if (this._connection) {
            return !(this._connection.destroyed || this._connection.closed);
        }
        return false;
    }
    /**
     * Reconnect and re-open readRows channel.
     */
    reconnect() {
        this.trace('reconnect called');
        this.close();
        this.open();
    }
    /**
     * Close the read stream connection.
     */
    close() {
        if (this._connection) {
            this._connection.end();
            this._connection.removeAllListeners();
            this._connection.destroy();
            this._connection = null;
        }
        if (this._readStream) {
            this._readStream.destroy();
            this._readStream = null;
        }
    }
}
exports.ReadStream = ReadStream;
//# sourceMappingURL=read_stream.js.map