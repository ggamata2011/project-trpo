"use strict";
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadSession = void 0;
const stream_1 = require("stream");
const protos = require("../../protos/protos");
const logger_1 = require("../util/logger");
const ReadSessionInfo = protos.google.cloud.bigquery.storage.v1.ReadSession;
/**
 * A ReadSession represents a Read Session from the BigQuery
 * Storage Read API.
 *
 * Read more on:https://cloud.google.com/bigquery/docs/reference/storage/rpc/google.cloud.bigquery.storage.v1#readsession
 *
 * @class
 * @memberof reader
 */
class ReadSession {
    constructor(readClient, tableRef, format) {
        this._info = null;
        this._format = format;
        this._tableRef = tableRef;
        this._readClient = readClient;
        this._readStreams = [];
    }
    getSessionInfo() {
        return this._info;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    trace(msg, ...otherArgs) {
        var _a;
        (0, logger_1.logger)('session', `[session: ${(_a = this._info) === null || _a === void 0 ? void 0 : _a.name}]`, msg, ...otherArgs);
    }
    async getOrCreateSession(options) {
        var _a;
        if (this._info) {
            return this._info;
        }
        const session = await this._readClient.createReadSession({
            parent: `projects/${this._tableRef.projectId}`,
            table: `projects/${this._tableRef.projectId}/datasets/${this._tableRef.datasetId}/tables/${this._tableRef.tableId}`,
            dataFormat: this._format,
            selectedFields: (_a = options === null || options === void 0 ? void 0 : options.selectedFields) === null || _a === void 0 ? void 0 : _a.split(','),
        });
        this.trace('session created', session.name, session.streams, session.estimatedRowCount);
        this._info = session;
        this._readStreams = [];
        for (const readStream of session.streams || []) {
            const r = await this._readClient.createReadStream({
                streamName: readStream.name,
                session,
            }, options);
            this._readStreams.push(r);
        }
        return session;
    }
    /**
     * Get a merged stream of ReadRowsResponse from all ReadStream
     * under this ReadSession.
     *
     * @param {GetStreamOptions} options
     */
    async getStream(options) {
        this.trace('getStream', options);
        await this.getOrCreateSession(options);
        const mergedStream = mergeStreams(this._readStreams.map(r => {
            const stream = r.getRowsStream();
            return stream;
        }));
        const joined = stream_1.Readable.from(mergedStream);
        this.trace('joined streams', joined);
        const stream = joined;
        return stream;
    }
    close() {
        this._readStreams.forEach(rs => {
            rs.close();
        });
    }
}
exports.ReadSession = ReadSession;
async function* mergeStreams(readables) {
    for (const readable of readables) {
        for await (const chunk of readable) {
            yield chunk;
        }
    }
}
//# sourceMappingURL=read_session.js.map